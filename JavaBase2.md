[10.18]

1.서블릿(Servlet)
- 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램
- 서버용 애플릿(자바로 구성된 소규모 프로그램), 웹서버에서 실행되는 작은 자바 코드
- JVM에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함
- 웹브라우저에서 실행되지 않고 GUI로 구성되지 않는다는 점이 애플릿과 다름
- 웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용

2.JSP(Java Server Page)
- 자바를 기반으로 하는 스크립트 언어
- 자바 언어를 기반으로 하고 있어서 플랫폼에 상관없이 사용 가능
- 표현언어, 표현식, 스크립트릿 등의 다양한 스크릿트 요소와 액션 태그 등을 제공함으로써 더 쉽게 웹 어플리케이션을 개발 가능

3.서블릿과 JSP 비교
- Servelt : 자바 코드에 html 삽입(용도 : 처리)
- JSP : html 내에 자바 코드 삽입(용도 : 출력)

4.데이터 전송 
- Servlet → JSP
  - 애트리뷰트(attribute)를 이용, 이 과정에서 파라미터(parameter)는 잘 사용되지 않음
  - 전송: request.setAttribute("속성명", 데이터); 혹은 session.setAttribute("속성명", 데이터);
  - 처리: (변경할 타입명)request.getAttribute("속성명"); 혹은 (변경할 타입명)session.getAttribute("속성명");
- HTML / JSP → Servlet
  - 서블릿 파일은 HttpServletRequest객체를 이용하여, Parameter값을 얻음
  - 파라미터 이외에는 데이터 전송과 관련한 다른 선택 가능한 수단이 없음, 파라미터는 곧 주소

5.서블릿에서 데이터를 처리하는 방식
- get
  - 서버에 있는 정보를 가져오기 위해 설계됨, 240바이트까지 전달 가능
  - post 방식에 비해 속도가 빠름
  - url 노출로 보안성이 요구되는 경우엔 사용할 수 없음
  - 검색엔진에서 검색단어 전송에 많이 이용함
- post
  - 서버로 정보를 올리기 위해 설계됨, 데이터 크기의 제한이 없음
  - get 방식에 비해 속도가 느림
  - url 에 파라미터가 표시되지 않음
  - 내부적으로 데이터가 이동함

6.서블릿의 실행 과정
1) 서버가 클라이언트의 연결 요청을 받는다.
2) 웹 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 연결 응답 정보를 담고 있는 Response 객체를 생성한다.
3) 접수된 URL 을 분석 후 해당 서블릿 객체를 생성하고, 사용자의 요청을 처리하기 위해 스레드를 생성 후 service() 메소드에 인자값을 담아 호출한다.
4) service() 메소드는 Request 객체를 참고하여 어떤 연결 요청 방식으로 들어왔는지 파악한다.
5) get 방식은 doGet(), post 방식은 doPost() 메소드를 호출하여 처리한다.
6) service() 메소드의 인자값으로 넘겨받은 response 객체를 이용하여 클라이언트에게 결과를 보여준다.
7) 사용자 요청을 처리하기 위해 생성한 스레드를 소멸시킨다.

7.서블릿 라이프 사이클(생명 주기)
- 서블릿은 javax.servlet.GenericServlet 클래스나 javax.servlet.HttpServlet 클래스를 상속받아서 작성
- init(), service(), destroy()의 세 개의 메소드에 의한 생명 주기를 가짐
- 서블릿이 로딩될 때 단 한 번 init() 메소드를 호출
- 클라이언트의 요청이 있을 때마다 service() 메소드를 반복적으로 호출
- 서블릿 객체는 메모리를 해제하기 위해서 destroy() 메소드를 호출

8.JSP 에서 페이지 이동 방법
- Forward 방식
  - url이 바뀌지 않음
  - 요청 객체와 응답 객체가 유지됨
  - 속도가 빠르며 '요청' 객체에 소속되어 있음
  - 요청이 들어오면 Servlet이 받음
  - 요청에 알맞은 페이지를 찾음, 알맞은 페이지가 있다면 응답
  - 알맞은 페이지가 없다면 포워딩 방식으로 알맞은 페이지로 넘김
  - 이때 요청 객체와 응답 객체를 포함해서 넘김
  - url 이 바뀌지 않은 상태로 응답 페이지를 통해 응답
- Redirect 방식
  - url이 바뀜
  - 요청 객체와 응답 객체가 유지되지 않음
  - 속도가 느리며, '응답' 객체에 소속되어 있음
  - 요청이 들어오면 Servlet이 받음
  - 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답
  - 알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청하게끔 응답을 보냄
  - 클라이언트는 응답을 받고, 다시 그 요청의 맞는 url로 요청함

9.JSP 생명주기
- 초기화, 서비스, 파괴의 과정을 거친다.
- jspInit() 메소드는 단 한번 호출하며 jspService() 메소드는 서비스 요청이 있을 때마다 호출하게 된다. 
- 클라이언트에서 jsp 문서를 클릭하게 되면 jsp 문서는 Servlet으로 변환되고, 
- 그 변환된 Servlet에서 처음으로 jspInit() 메소드가 호출된다.

10.패턴(Pattern)
- FrontController 패턴 : 여러 개의 요청을 하나의 Servlet 이 처리
- Model 1 패턴 : 일반적으로 모든 코드를 JSP에 작성
- Model 2 패턴 : 출력은 JSP가 수행하고 처리는 Servlet이 수행함, 유지보수가 쉽지만 구조가 복잡함, 대규모 프로젝트에 이용
  - Model 1 패턴이 JSP 에 프레젠테이션 로직과 비즈니스 로직, 데이터 접근 로직이 함께 들어갔던 반면,
  - Model 2 패턴은 각각의 역할을 나누어 작업을 분담함
- MVC 패턴 : Model, View, Control 의 역할을 확실하게 분리해놓은 프로그래밍 기법(별도의 객체로 처리)
  - 중간에 Controller 컴포넌트를 두어 비즈니스 로직과 데이터 접근 로직, 프레젠테이션 로직을 분리한 디자인 패턴
  - 역할이 구분되어 모듈 간의 의존성을 낮추어 재사용성 및 확장이 쉬운 구조이므로 유지보수에 유리함
  - View를 담당하는 JSP는 프레젠테이션 로직만을 처리하고 데이터를 출력함
  - Controller는 연결하는 부분으로 요청을 어디로 보낼지 결정함
  - Model은 데이터를 만드는 부분임

11.Spring  
- Java Enterprise Application 개발에 사용되는 Application Framework 
- 개발을 빠르고 효율적으로 할 수 있도록 Application의 바탕이 되는 틀과 공통프로그래밍 모델, 기술 API를 제공  
- 종속 객체 주입이라는 기술을 통해 낮은 결합도를 유지할 수 있음  
- AOP 를 이용하여 객체 지향만이 아닌 관심 지향 기법을 활용  
- EJB(엔터프라이즈 자바빈즈) 기능 대체 가능
- 트랜잭션 처리를 위한 일관된 방법을 제공  
- 계층 간 연결이 인터페이스로 이루어지기 때문에 인터페이스 생성이 필요  
- 다양한 프레임워크와의 통합 가능 
- 실행 순서
  - web.xml 에 등록된 DispatcherServlet 을 통해서 요청에 대해 진입  
  - DispatcherServlet 은 Client 로부터 들어온 URL을 HandlerMapping 이라는 곳으로 전송 후  
  - URL 을 분석해서 알맞은 Controller 이름을 다시 DispatcherServlet 으로 보냄  
  - HandlerMapping 이라는 것을 통해서 실행될 Controller 의 이름을 입력받은 DispatcherServlet 은 전달받은 Controller 를 실행시킴  
  - 이렇게 실행된 Controller 는 스프링에서 제공하는 ModelAndView 객체에 View 페이지에 전달할 객체와 View 페이지 이름 정보를 담고 DispatcherServlet 으로 보냄  
  - ViewResolver 를 통해 보여질 View 페이지를 탐색한 후 View 페이지를 보여줌

12.mybatis (iBatis)
- Persistence 계층(=데이터 처리 계층, DB에 데이터를 CRUD하는 계층)의 프레임워크
- 정형화된 테이블 구조에 의존하지 않고 SQL 구문의 실행 결과에 객체를 매핑 하는 방식
- 테이블 구조가 정규화되어있지 않더라도 테이블을 변경할 필요없이 기존 개발 방법에서 사용한 SQL을 그대로 사용 가능
- sql문과 프로그래밍 코드의 분리가 이루어지고 다양한 프로그래밍 언어로 구현이 가능함
- 즉, Java 에서 DataBase를 편하게 Handling 할 수 있게 해주는 프레임워크
- SQL 문과 Java 코드와의 분리만으로도 자바 개발자는 쿼리문을 신경 쓰지 않아도 됨
- (SQL문이 변경되더라도 파라미터 값만 변경되지 않는다면 자바 소스에서 수정할 부분이 없기 때문)
- 실행 순서
1) 자바 코드 내에서 특정 쿼리문을 실행하기를 원할 때 파라미터와 필요한 조건을 넘기기 위한 객체를 생성
2) SQLMaps 를 실행하기 위해 쿼리의 객체와 이름 넘기기
3) 쿼리가 실행되었을 때 SQLMaps 는 쿼리 결과를 받기 위해 정의된 클래스의 인스턴스를 생성하게 됨  
  - SQLMaps는 자바 빈즈를 PreparedStatement 파라미터와 ResultSet으로 매핑 시켜주는 기능을 담당함
  - 인스턴스는 데이터베이스에 의해 반환된 ResultSet으로부터 만들어짐

13.프로세스(process) 와 쓰레드(thread)
- 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 Process가 되고,
- Process는 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원과 쓰레드로 구성됨
- 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 '쓰레드(thread)'임
- 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재함
- 둘 이상의 쓰레드를 가진 프로세스를 '멀티쓰레드 프로세스(multi-threaded process)'라고 함
- 즉, 쓰레드를 이용하면 한 프로세스에서 두 가지 이상의 일을 동시에 할 수 있음

14.TCP vs UDP (= 전송 계층)
- TCP(Transmission Control Protocol): 전송 제어 프로토콜
- 기능: 데이터전송, 연결지향
- UDP(User Datagram Protocol): 사용자 데이터그램 프로토콜
- 특징: 무연결, 패킷 전송에 대한 보증을 제공하지 않으므로 TCP보다 빠름

15.ArrayList vs List
- ArrayList : ArrayList arrayList = new ArrayList();
  - 자료형을 지정해주지 않아도되어 쓰기 편하지만 추가하거나 뺄 때 추가 연산이 필요하므로 연산량이 많음
  - ArrayList에는 자료형이 존재하지 않아 어느 타입이든 추가할 수 있음
- List : List<int> list = new List<int>();
  - ArrayList와는 다르게 타입을 지정해주는 것 말고는 동일함
  - 타입을 지정해주므로 ArrayList보다 연산량이 적음

16.getter vs setter
- get = 불러오기
- set = 저장하기
- 외부로부터 변수값에 직접적으로 접근하게 되면 값이 변하게 되고 데이터 무결성이 깨질 수 있으므로 사용하게 됨




