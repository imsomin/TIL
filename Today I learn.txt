<Computer Science 개념 공부>

[10.13]
1. 컨테이너
- 클라이언트의 요청에 따른 리소스를 찾고 자바 코드를 html 코드로 변환하여 응답 및 전송해주는 임무 수행
 ex)Tomcat8.5, Jeus, JBoss


2. 통합 개발 환경(IDE)
- 코드를 작성하고 빌드해줄 수 있는 툴
 ex)이클립스


3. 컴파일
- 작성한 소스 코드(.java)는 자바 컴파일러의 컴파일 과정을 통해 자바가상머신(JVM)이 
  인식할 수 있는 바이트 코드를 생성해내고, 이렇게 만들어진 파일(.class)을 자바런처가 
  execute(실행)하게 된다.


4. 서블릿과 JSP 비교
- Servelt : 자바 코드에 html 삽입(용도 : 처리)
- JSP : html 내에 자바 코드 삽입(용도 : 출력)


5. 데이터 전송 
- Servlet -> JSP
: 애트리뷰트(attribute)를 이용한다. 이 과정에서 파라미터(parameter)는 잘 사용되지 않는다.
: 전송
  request.setAttribute("속성명", 데이터); 
  session.setAttribute("속성명", 데이터)
: 처리
  (변경할 타입명)request.getAttribute("속성명");
  (변경할 타입명)session.getAttribute("속성명");

- HTML / JSP -> Servlet
: 서블릿 파일은 HttpServletRequest객체를 이용하여, Parameter값을 얻음.
: 파라미터 이외에는 데이터 전송과 관련한 다른 선택 가능한 수단이 없다. 파라미터는 곧 주소다.


6. 패턴 Pattern
-FrontController 패턴 :여러 개의 요청을 하나의 Servlet 이 처리

-Model 1 패턴 :일반적으로 모든 코드를 JSP에 작성

-Model 2 패턴 :출력은 JSP가 수행하고, 처리는 Servlet이 수행
 유지보수가 쉽지만, 구조가 복잡함, 대규모 프로젝트에 이용

-MVC 패턴 : 데이터를 만드는 부분(model)과 데이터를 출력하는 부분(view) 및 
 연결하는 부분(Controller)을 별도의 객체로 처리함
 이 모든 과정은 독립성을 갖도록 해서 유지보수를 용이하게 하기 위함임
 보통 Model2 MVC 패턴을 만든다.



[10.17]
1.JAVA의 특징
- 플랫폼에 독립적인 객체지향언어
- 개발환경에 제약받지 않고, 어느 플랫폼에서나 코드의 호환성과 재사용이 자유로움
- 동적 로딩을 지원(객체가 필요한 시점에 클래스를 동적 로딩하여 생성)
- 운영체제에 독립적 즉 프로그램을 다시 컴파일 할 필요 없이 실행 가능함


2.JDK 1.5 부터 추가된 항목
- 확장 for문, 비정형 인자, 제네릭, 오토박싱, 오토언박싱, 어노테이션 등


3.Overloading(메소드 중복정의)과 Overriding(메소드 재정의)
- 오버로딩 : 기존 메소드의 인자를 이용하여 하나의 함수에 여러 기능을 만드는 것
- 오버라이딩 : 상위 클래스에 있는 메소드와 똑같은 메소드를 하위 클래스에서 다시 만드는 행위
               즉, 하위 클래스에서 메소드를 재정의하는 것을 말한다(다형성)


4.객체(object)
- 클래스에 정의된 내용대로 메모리에 생성된 것


5.클래스
- 객체를 만드는 설계도, 객체를 생성하는 틀

 
6.객체와 인스턴스
- 클래스로부터 객체를 만드는 과정을 '클래스의 인스턴스화'라고 함
- 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함


7.인스턴스(Instance)
- 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿(형식, 틀, 모형)이 실제 구현된 것


8.객체 지향 프로그래밍(OOP, Object-Oriented Programming)
- 컴퓨터 프로그램을 여러 개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 함
- 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음

 
9.캡슐화(Encapsulation)
- 하나의 문제를 해결하기 위한 데이터와 메소드를 하나의 단위로 묶는다는 것
- 클래스의 내부 정의에 대해 외부에서 볼 수 없도록 하는 것이 특징(은닉화)

 
10.추상화(Abstraction)
- 모델(Object)의 자세한 성질을 숨기고 일반적인 성질을 나타내는 것
- 일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의
  공통적인 성질과 행위를 일반화하여 디자인되며,
  그로부터 생성된 객체는 자신의 고유의 성질을 가지게 됨.

 
11.다형성(Polymorphism)
- 같은 메시지에 대해 클래스에 따라 다른 행위를 하게 되는 특징
- 일반적으로 같은 이름을 가지는 메소드에 대해 인자(Argument)의 개수와 
  데이터형(Data Type)에 따라 수행되는 행위가 달라진다. 
- 다형성을 통해서 사용자는 약속된 인터페이스를 따르는 서로 다른 객체를 같은 방식으로 사용할 수 있게 된다.


12.매개변수 vs 인자
- 매개변수(파라미터 또는 parameter)는 함수 이름 뒤에 괄호안에 선언하는 변수이고, 
- 인자(인수 또는 argument)는 함수 호출시 전달하는 값을 말한다. 

 
13.상속(Inheritance)
- 기존에 있던 클래스를 바탕으로 다른 특성을 추가하여 새로운 클래스를 만들 수 있음
 

14.인터페이스
- 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상 자료형
- 상수 또는 추상 메소드만 정의할 수 있으며, 구현된 메소드는 포함할 수 없음
- 모든 변수는 static이고 final 임
- 자식 클래스들이 공통된 메소드를 포함하도록 함
- 다중 상속이 가능


15.추상화
- 자바에서 공통의 속성, 기능을 묶어 이름을 붙이는 것을 의미한다.
- 자바에서 추상화는 추상클래스, 인터페이스를 통해 구현된다.


16.추상(abstract) 클래스
- 클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다.
- 즉, 그대로 완성되지 못한 채로 남겨진 설계도를 의미한다.
- 클래스가 미완성이라는 것은 미완성 메소드(추상 메소드)를 포함하고 있다는 의미이다.
- 미완성 설계도로 완성된 제품을 만들 수 없듯이, 추상클래스로 인스턴스는 생성 불가능함
  추상클래스는 상속을 통해서 자손클래스에 의해서만 완성 가능
- 'new'로 객체를 생성할 수 없음
- 미완성 상태로 남겨 놓은 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문임


17.추상 클래스와 인터페이스의 공통점
- 객체를 발생시킬수 없음
- 상속하여 하위 클래스를 통해 객체를 발생시킴
- 메소드를 재정의해야 함


18.예외 처리의 필요성과 목적
- 자바에서 프로그램의 실행 도중, 예외가 발생하면 발생된 그 시점에서 프로그램이 바로 종료된다.
  하지만 가벼운 예외이거나 예상 가능한 예외의 경우일 수도 있으므로 '예외 처리'라는 수단이 제안되었고,
  예외 처리를 통해 우선 프로그램의 비정상적인 종료를 막고 발생한 예외에 대한 처리로 정상적인 프로그램을 
  계속 진행할 수 있도록 하는 것이 예외 처리의 필요성이라 할 수 있다.
- 예외의 발생으로 실행 중인 프로그램의 갑작스러운 비정상 종료를 막고, 
  정상적인 실행 상태를 유지할 수 있도록 하는 것


19.String vs StringBuffer vs StringBuilder
- String 클래스 : 상수 문자열, 한번 생성한 후 변하지 않는 문자열 용도
- StringBuffer 클래스 : 프로그램 내에서 계속 변하는 문자열 용도
- StringBuilder 클래스 : StringBuilder 는 Java5에서 추가된 클래스로 StringBuffer 와 기능이 같다. 
  차이점은 스트링버퍼는 동기화가 되지만 스트링빌더는 그렇지 않다는 것이다. 
  즉, 스트링빌더는 다중 thread 에서는 안전하지 않으므로 동기화가 필요한 경우에는 
  스트링버퍼를 사용하는 것이 좋다.


20.Stream
- 데이터를 목적지로 입출력하기 위한 방법
- 스트림에 데이터를 쓰고 읽을 수 있음
- 스트림은 FIFO(First In First Out)구조로 읽기와 쓰기가 동시에 되지 않음
- 읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야 함


21. Statement vs PreparedStatement
- Statement
:정적 쿼리 시 사용
 매번 parsing(=구문 분석) 과정을 거쳐야 하므로 부하가 생길 수 있음
 SQL문 전체를 명확히 알 수 있어서 디버깅(=프로그래밍에서 잘못된 부분을 찾아 고치는 것)이 쉬움
- PreparedStatement
:동적 쿼리 시 사용
 한번 parsing하면 동일한 sql문장을 곧바로 파싱 과정 없이 실행(Execution)할 수 있음
 반복적인 다량의 sql 수행 시 성능상 이득이 있음
 오류 발생 시 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움 
 

22.Java Beans
- 자바에서 컨포넌트를 이용하는 데 활용되는 기술
- 컴포넌트를 사용하면 좋은 이유는 필요할 때마다 가져다가 사용할 수 있다는 점인데
  JSP에서 자바의 컴포넌트를 이용해서 프로그래밍하는 것을 빈즈 프로그래밍이라 함.


23.컴포넌트
- 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈을 의미함


24.Connection Pool
- 미리 생성해 놓은 커넥션을 할당하고 반납함으로써 커넥션 생성 시간을 줄인다는 개념
- 미리 생성할 때 너무 조금 생성하면 타임 오버헤드가 늘어나고, 
  반대로 너무 많이 생성하면 메모리 오버헤드가 늘어난다.


25. Singleton
- 프로그래밍 디자인 패턴
- 발전된 형태의 전역 변수 개념
- 프로그램상에서 두 번째 인스턴스를 만들 수 없게 하는 기능
- 만들어진 클래스의 객체를 단 하나만 사용하며 어디서든 그 객체를 사용할 수 있도록 만듬
+ 디자인 패턴이란?
  :기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것인가에 대한 일종의 솔루션


26.WAS(Web Application Server) = 웹 어플리케이션 서버, 웹 응용 서버
- 서버와 클라이언트 사이에 있는 3-tier 방식
- Server가 처리하는 양이 많아지면서 Server 에 생기는 부하를 해결하기 위해 개발됨
  WAS로 인해 안정된 시스템 구성이 가능하여 안정적 서비스 보장 가능
- Client 에서 요청이 들어오면 실제적인 처리는 WAS가 하고 
  서버는 단지 Client 에 결과 값을 뿌려주는 역할만 하게 됨
- 즉, '동적' 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버
  (DB조회, 로직처리가 요구되는 컨텐츠)
cf. Web Server = 웹 서버
  : 클라이언트가 서버에 페이지 요청을 하면 요청을 받아 
    '정적' 컨텐츠(.html, .png, .css등)을 제공하는 서버 -> 대표) Apache, nginx



[10.18]
1. JVM(Java Virtual Machine)
- 컴파일된 자바클래스를 실행할 수 있도록 자바에서 제공하는 가상머신
- 즉, 자바를 실행하기 위한 가상 기계


2.서블릿(Servlet)
- 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해
  자바로 작성된 프로그램
- 서버용 애플릿(자바로 구성된 소규모 프로그램), 웹서버에서 실행되는 작은 자바 코드
- JVM에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함
- 웹브라우저에서 실행되지 않고 GUI로 구성되지 않는다는 점이 애플릿과 다름
- 웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용


3.서블릿에서 데이터를 처리하는 방식
- get
:서버에 있는 정보를 가져오기 위해 설계됨, 240바이트까지 전달 가능
 post 방식에 비해 속도가 빠름
 url 노출로 보안성이 요구되는 경우엔 사용할 수 없음
 검색엔진에서 검색단어 전송에 많이 이용함
- post
:서버로 정보를 올리기 위해 설계됨, 데이터 크기의 제한이 없음
 get 방식에 비해 속도가 느림
 url 에 파라미터가 표시되지 않음
 내부적으로 데이터가 이동함


4.서블릿의 실행 과정
1) 서버가 클라이언트의 연결 요청을 받는다.
2) 웹 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 
   연결 응답 정보를 담고 있는 Response 객체를 생성한다.
3) 접수된 URL 을 분석 후 해당 서블릿 객체를 생성하고,
   사용자의 요청을 처리하기 위해 스레드를 생성 후
   service() 메소드에 인자값을 담아 호출한다.
4) service() 메소드는 Request 객체를 참고하여
   어떤 연결 요청 방식으로 들어왔는지 파악한다.
5) get 방식은 doGet(), post 방식은 doPost() 메소드를 호출하여 처리한다.
6) service() 메소드의 인자값으로 넘겨받은 response 객체를 이용하여 
   클라이언트에게 결과를 보여준다.
7) 사용자 요청을 처리하기 위해 생성한 스레드를 소멸시킨다.


5.서블릿 라이프 사이클(생명 주기)
- 서블릿은 javax.servlet.GenericServlet 클래스나 javax.servlet.HttpServlet 클래스를 
  상속받아서 작성하며, init(), service(), destroy()의 세 개의 메소드에 의한 생명 주기를 갖는다.
- 서블릿이 로딩될 때 단 한 번 init() 메소드를 호출하게 되며 
  클라이언트의 요청이 있을 때마다 service() 메소드를 반복적으로 호출하게 된다. 
  서블릿 객체는 메모리를 해제하기 위해서 destroy() 메소드를 호출하게 된다.

 
6.JSP(Java Server Page)
- 자바를 기반으로 하는 스크립트 언어
- 자바 언어를 기반으로 하고 있어서 플랫폼에 상관없이 사용 가능
- 표현언어, 표현식, 스크립트릿 등의 다양한 스크릿트 요소와 액션 태그 등을
  제공함으로써 더 쉽게 웹 어플리케이션을 개발 가능


7.JSP 에서 페이지 이동 방법
- Forward 방식
: url이 바뀌지 않음
  요청 객체와 응답 객체가 유지됨
  속도가 빠르며 '요청' 객체에 소속되어 있음
: 요청이 들어오면 Servlet이 받음
  요청에 알맞은 페이지를 찾음, 알맞은 페이지가 있다면 응답
  알맞은 페이지가 없다면 포워딩 방식으로 알맞은 페이지로 넘김
  이때 요청 객체와 응답 객체를 포함해서 넘김
: url 이 바뀌지 않은 상태로 응답 페이지를 통해 응답
- Redirect 방식
: url이 바뀜
  요청 객체와 응답 객체가 유지되지 않음
  속도가 느리며, '응답' 객체에 소속되어 있음
: 요청이 들어오면 Servlet이 받음
  요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답
  알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청하게끔 응답을 보냄
  클라이언트는 응답을 받고, 다시 그 요청의 맞는 url로 요청함


8.JSP 생명주기
- 초기화, 서비스, 파괴의 과정을 거친다.
- jspInit() 메소드는 단 한번 호출하며 
  jspService() 메소드는 서비스 요청이 있을 때마다 호출하게 된다. 
- 클라이언트에서 jsp 문서를 클릭하게 되면 
  jsp 문서는 Servlet으로 변환되고, 
  그 변환된 Servlet에서 처음으로 jspInit() 메소드가 호출된다.


9.JSP vs Javascript
- JSP는 자바에서 파생된 서버 스크립트이며, 서버 사이드 스크립트로서 웹페이지를 작성함
- 자바스크립트는 클라이언트 사이드 스크립트이며, 브라우저의 객체를 제어하는 데 쓰임


10.쿠키와 세션의 차이
- 쿠키
: 클라이언트에 정보를 저장하기 때문에 서버에 부하가 없음. 
  사라지는 시간을 지정할 수 있음.
- 세션
: 서버에 정보를 저장하기 때문에 서버에 부하가 많이 생김. 
  해당 클라이언트와 일정 시간 동안 작용이 없으면 서버 메모리에서 해제됨. 
  직접적으로 해제시킬 수 있는 메소드가 있음


11.Framework
- 특정 형태의 소프트웨어 문제를 해결하기 위해, 상호 협력하는 클래스들과 인터페이스의 집합
- 장점 : 재사용성, 단순성, 역할 구분, 확장성, 유지보수용이
- 프레임워크와 라이브러리 차이
: 라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음
: 프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공.


12.MVC 패턴
- Model, View, Control 의 역할을 확실하게 분리해놓은 프로그래밍 기법
- 중간에 Controller 컴포넌트를 두어 비즈니스 로직과 데이터 접근 로직, 
  프레젠테이션 로직을 분리한 디자인 패턴이다.
- 역할이 구분되어 모듈 간의 의존성을 낮추어 재사용성 및 확장이 쉬운 구조이므로 유지보수에 유리하다.
- 모델1이 JSP 에 프레젠테이션 로직과 비즈니스 로직, 데이터 접근 로직이 함께 들어갔던 반면 
  모델2는 각각의 역할을 나누어 작업을 분담한다.
- 뷰를 담당하는 JSP는 프레젠테이션 로직만을 처리하고 컨트롤러는 요청을 어디로 보낼지 결정한다. 
  그리고 모델은 비즈니스 레이어에 포함된다.


13.Spring  
- Java Enterprise Application 개발에 사용되는 Application Framework.  
- 개발을 빠르고 효율적으로 할 수 있도록 Application 의 바탕이 되는 틀과 공통프로그래밍 모델, 
  기술 API를 제공  
- 종속 객체 주입이라는 기술을 통해 낮은 결합도를 유지할 수 있음  
- AOP 를 이용하여 객체 지향만이 아닌 관심 지향 기법을 활용  
- EJB(엔터프라이즈 자바빈즈) 기능 대체 가능. 트랜잭션 처리를 위한 일관된 방법을 제공  
- 계층 간 연결이 인터페이스로 이루어지기 때문에 인터페이스 생성이 필요  
- 다양한 프레임워크와의 통합 가능 
- 실행 순서
1) web.xml 에 등록된 DispatcherServlet 을 통해서 요청에 대해 진입  
2) DispatcherServlet 은 Client 로부터 들어온 URL을 HandlerMapping 이라는 곳으로 전송 후  
3) URL 을 분석해서 알맞은 Controller 이름을 다시 DispatcherServlet 으로 보냄  
4) HandlerMapping 이라는 것을 통해서 실행될 Controller 의 이름을 입력받은 DispatcherServlet 은 
   전달받은 Controller 를 실행시킴  
5) 이렇게 실행된 Controller 는 스프링에서 제공하는 ModelAndView 객체에 
   View 페이지에 전달할 객체와 View 페이지 이름 정보를 담고 DispatcherServlet 으로 보냄  
6) ViewResolver 를 통해 보여질 View 페이지를 탐색한 후 View 페이지를 보여줌


14. DI & AOP
- DI
: Dependency Injection 의 약자로 의존성 주입이라는 의미  
  스프링을 적용하여 applicationContext.xml 에서 설정만 해주면 외부의 설정 파일(xml)에서  
  연관 관계에 있는 객체를 주입해주기 때문에 의존 객체를 찾기 위한 코드가 필요하지 않게 됨  
  즉, 외부설정에서 객체를 찾아서 쓰기 때문에 코드 내에 의존관계를 맺는 코드 생성이 불필요함.  
- AOP
: Aspect Oriented Programming 의 약자로 관심 지향 프로그래밍을 의미
  프로그래밍할 때 특정한 관심사를 가진 코드 부분을 별도의 모듈로 분리함으로써,
  기존 객체 지향의 강력한 기능(상속, 위임)만으로는 처치가 곤란했던 중복을 제거할 수 있게 됨  


15.mybatis (iBatis)
- mybatis는 Persistence 계층(데이터 처리 계층)의 프레임워크로, 
  다른 객체 관계 매핑 프레임워크들과는 달리 정형화된 테이블 구조에 의존하지 않고 
  SQL 구문의 실행 결과에 객체를 매핑 하는 방식으로 테이블 구조가 복잡해지고 정규화되어있지 않더라도 
  테이블을 변경할 필요없이 기존 개발 방법에서 사용한 SQL을 그대로 사용할 수가 있으며, 
  SQL에 적용한 튜닝들도 모두 그대로 유지된다.
- 즉, Java 에서 DataBase를 편하게 Handling 할 수 있게 해주는 프레임워크
- SQL 문과 Java 코드와의 분리만으로도 자바 개발자는 쿼리문을 신경 쓰지 않아도 됨
  (SQL문이 변경되더라도 파라미터 값만 변경되지 않는다면 자바 소스에서 수정할 부분이 없기 때문)
- 실행 순서
1) 자바 코드 내에서 특정 쿼리문을 실행하기를 원할 때, 파라미터와 필요한 조건을 넘기기 위한 객체를 생성
2) SQLMaps 를 실행하기 위해 쿼리의 객체와 이름을 넘겨 줌.
3) 쿼리가 실행되었을 때 SQLMaps 는 쿼리 결과를 받기 위해 정의된 클래스의 인스턴스를 생성하게 됨  
4) 인스턴스는 데이터베이스에 의해 반환된 ResultSet으로부터 만들어짐.
+SQLMaps는 자바 빈즈를 PreparedStatement 파라미터와 ResultSet으로 매핑 시켜주는 기능을 담당한다.


16.AJAX(Asynchronous JavaScript and XML)
- 비동기식으로 Javascript 를 이용해 클라이언트 측에서 페이지 리로딩 없이 필요한 데이터를 얻어내는 기법  
- 페이지 이동 없이 화면을 전환할 수 있으며 서버 처리를 기다리지 않고 비동기 요청이 가능하다.  
- 수신하는 데이터양을 줄일 수 있고, 클라이언트에게 처리를 위임할 수 있다는 장점이 있다.  
- 필요한 데이터만 서버로 보내고 해당 정보만 받음
- 서버로부터 정보를 받을 때는 xml 이나 json 형태로 받고 
  클라이언트에서는 그 정보들을 DOM 을 통해 화면을 재가공하여 보여주기 때문에 
  서버와 교환되는 데이터의 양이 적어지므로 점유율을 낮출 수 있음  
- 클라이언트에서 데이터를 처리하므로 서버에 부담이 덜 가기 때문에 다른 응답 요청에 신속히 응대 가능
+ ajax 동기 vs 비동기의 차이점
-> 동기 통신  :서버가 작업이 끝날 때까지 기다리는 통신 방식
-> 비동기 통신:서버 컴퓨터가 작업이 끝날 때까지 기다리지 않는 통신
               (서버에 요청 저장이 될 때까지 기다리지 않고 진행)


17.DOM(Document Object Model), 문서 객체 모델
- JavaScript Node 개체의 계층화된 트리임
- HTML, XML 문서의 프로그래밍 API임
- 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법 제공
- 문서 구조, 스타일, 내용 등을 변경할 수 있게 도움


18.ERD(Entity Relationship Diagram)
- 개체관계도
- 구두 언어로 되어있는 요구분석사항을 그림으로 그려내어 그 관계를 도출하는 것


19.트랜잭션(Transaction) 
- 트랜잭션이란, 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위를 뜻한다.  
- 데이터베이스의 상태를 변화시킨다는 것은 간단하게 말해, SQL을 이용하여 데이터베이스에 접근하는 것을 의미한다.  
  (-> select, insert, delete, update)
- 트랜잭션의 특징 : 원자성, 일관성, 독립성, 지속성


20. 자바 접근 제어자의 종류와 각각의 제한 범위
- 접근 제어자(Access Modifier)란?
  :멤버 변수와 클래스 변수를 외부에서 접근하지 못하도록 제한하는 역할을 하는 제어자

-public : 접근 제한이 거의 없는 것으로 누구나 접근 가능
-protected : 같은 패키지, 자손 클래스까지 접근 가능
-default : 아무것도 표기하지 않은 상태, 같은 패키지 내에서는 접근 가능, default 붙이지 않음
-private : 같은 클래스 내에서만 접근 가능, setter와 getter 를 써서 내용 변경 가능



[10.21]
1. 프로세스(process) 와 쓰레드(thread)
- 실행 중인 프로그램(program)
- 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.
- 프로세스는 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원과 쓰레드로 구성됨
- 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 '쓰레드'이다.
- 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 둘 이상의 쓰레드를 가진 프로세스를
  '멀티쓰레드 프로세스(multi-threaded process)'라고 한다.
- 즉, 쓰레드를 이용하면 한 프로세스에서 두 가지 이상의 일을 동시에 할 수 있다


2. VCS(Version Control System), 형상관리
- 사본 생성, 보존, 복원을 한 번에 해줄 수 있는 도구로, 프로젝트 팀이 소스 관리 도구를 통해 배포 및 백업함


3. TCP vs UDP (=전송 계층)
- TCP(Transmission Control Protocol): 전송 제어 프로토콜
- 기능: 데이터전송, 연결지향

- UDP(User Datagram Protocol): 사용자 데이터그램 프로토콜
- 특징: 무연결, 패킷 전송에 대한 보증을 제공하지 않으므로 TCP보다 빠름


4. 동기화
-여러 명이 접근하는 것을 방지
-여러 명이 접근하는 것을 막기 위해 모든 객체에 lock 을 포함하는데, 
 lock 이란 공유 객체에 여러 thread가 동시에 접근하지 못하도록 하기 위한 것으로 
 모든 객체가 Heap 영역에 생성될 때 자동으로 만들어진다.


5. 힙(Heap)
- 인스턴스가 생성되는 공간으로 프로그램 실행 중 생성되는 인스턴스는 모두 해당 영역에 생성됨
- 인스턴스변수가 생성되는 공간


6. 스택과 큐
- Stack
: 모든 작업이 리스트의 한쪽 끝에서만 수행되는 선형 리스트의 한 형태  
  리스트의 한쪽 끝에서 원소를 삽입하거나 제거하는 데 사용  
  그러므로 리스트에서 스택에 마지막으로 입력된 원소가 제일 먼저 제거의 대상이 됨.  
  즉, 스택은 LIFO(Last In First Out) 구조임
- Queue
: 삽입은 Rear에서 이루어지고, 제거는 Front 에서 이루어짐
  큐를 FIFO(First In First Out)라고도 함


7. InnerClass vs OuterClass
- 내부클래스(InnerClass)
: 클래스 내에 선언된 클래스
: 한 클래스를 다른 클래스의 내부 클래스로 선언하면 두 클래스의 멤버들 간에 서로 접근할 수 있다는 장점과
  외부에는 불필요한 클래스를 감춰서 코드의 복잡성을 줄일 수 있다(->캡슐화)는 장점이 있다.
- 외부클래스(OuterClass)
: 내부 클래스를 감싸고 있는 클래스


8. 미들웨어(middleware)
- 애플리케이션들을 연결해 이들이 서로 데이터를 교환할 수 있게 중계 역할을 하는 소프트웨어

 
9. ORM 프레임워크 (Object Relational Mapping)
- 객체와 관계형 데이터베이스를 매핑한다는 의미의 'ORM'
- ORM 프레임워크를 사용함으로써 그동안 개발해왔던 INSERT/UPDATE/SELECT 쿼리 등을 
  직접 작성하지 않고도 데이터를 저장할 수 있게 됨
- 객체를 자바 컬렉션에 저장하듯 ORM 프레임워크에 저장하면 쿼리 작성 시의 업무 수행 가능
- ORM 프레임워크에 저장된 객체들은 ORM 프레임워크가 적절한 SQL을 생성해서 데이터베이스에 저장됨


10. JPA(Java Persistence API)
- 자바 진영의 ORM 기술 표준
- 자바 어플리케이션과 JDBC 사이에서 작동한다.  


11. Mybatis 프레임워크
- 자바 오브젝트와 sql문 사이의 자동 mapping 기능을 지원하는 ORM 프레임워크
- sql문과 프로그래밍 코드의 분리
- 다양한 프로그래밍 언어로 구현가능


12. POJO(Plain Old Java Object)
- 순수한 자바 오브젝트  
- 스프링이 등장하기 이전의 Java를 사용한 개발에서는 EJB(엔터프라이즈 자바빈즈)가 인기를 끌었고, 
  이로인해 종속적인 부분으로 개발을 진행하다보니 객체 자체는 무거워지고 불편함이 발생함 
- 이에 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고, 필요에 따라 재활용할 수 있는 방식을 설계함
- 특징: 특정 규약이나 환경에 종속되지 않음


13. MSA(MicroService Architecture) 마이크로서비스 아키텍처
- 하나의 큰 어플리케이션을 여러 개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처


14. ELK(ElasticStack) 엘라스틱 스택
- 모든 유형의 데이터를 저장, 검색, 분석 및 시각화를 가능하게 해주는 Elastic의 오픈소스


15.DNS(Domain Name System)
- 범국제적 단위로 웹사이트의 IP주소와 도메인 주소를 이어주는 환경/시스템
- 웹사이트의 데이터가 저장되어 있는 호스팅 서버는 아이피 주소가 할당되어 있고, 
  실제 웹사이트 주소라 할 수 있음.  
- DNS 서버는 이런 아이피 주소를 특정 도메인 주소와 같다는 기록을 저장해두고, 
  인터넷 사용자들이 도메인 주소를 검색했을 때 아이피 주소로 연결되도록 해줌.  


16.게이트웨이
- OSI 7 Layer 중 전송 계층에 해당하는 기기로, 서로 다른 프로토콜끼리도 네트워크 통신이 가능하도록
  연결해주는 역할을 한다.


17.암호화, 복호화
- 암호화: 제 3자가 읽을 수 없도록 부호화하여 암호문으로 만드는 것
- 복호화: 암호문을 평문으로 역부호화하는 것


18.Open API(Application Programming Interface)
- 인터넷 이용자가 일방적으로 웹 겸색 결과 및 사용자 인터페이스 등을 제공받는데 그치지 않고
  직접 응용 프로그램과 서비스를 개발할 수 있도록 공개된 API


19.Json vs XML
- XML(eXtensible Markup Language)
  : 데이터의 구조를 기술하기 위한 언어
  : 다른 시스템끼리 다양한 종류의 데이터 교환 가능케 함
  : 데이터를 전달하고 저장하는 것이 곧 목적임
- JSON(JavaScript Object Notation)
  : 자바스크립트를 기반으로 만들어짐
  : XML의 대안으로서 좀더 쉽게 데이터를 교환하고 저장하기 위하여 고안됨


20.자바 컬렉션(Java Collection)
- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스
- 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현함
- 'Collection'에서 데이터를 저장하는 3가지와 그 특징
   set  : 순서가 없고, 동일한 데이터 허용이 안 됨
   list : 배열과 같은 구조지만, 가변적 길이를 가지고 있음(크기가 지정되어 있지 않음)
   map  : key 값과 value 값의 형식으로 저장되면 key 값은 절대 중복이 안 됨


21. ArrayList vs List
- ArrayList
 ArrayList arrayList = new ArrayList();
: 자료형을 지정해주지 않아도되어 쓰기 편하지만 추가하거나 뺄 때 추가 연산이 필요하므로 
  연산량이 많다는 단점이 있음
: ArrayList에는 자료형이 존재하지 않는다. 즉, 어느 타입이든 추가할 수 있음

- List
 List<int> list = new List<int>();
: ArrayList와는 다르게 타입을 지정해주는 것 말고는 동일함
: 타입을 지정해주므로 ArrayList보다 연산량이 적음


22. JDBC(Java DataBase Connectivity)
- 자바 프로그램 안에서 SQL을 실행하기 위해 데이터베이스를 연결해주는 응용프로그램 인터페이스


23. getter vs setter
- get = 불러오기
- set = 저장하기
: 외부로부터 변수값에 직접적으로 접근하게 되면 값이 변하게 되고 데이터 무결성이 깨질 수 있다.


24. 문자기반의 보조스트림 vs 화면에서 입력받기
BufferedReader / BufferedWriter /InputStreamReader / OutputStreamWriter
vs 
Scanner


25.http vs https 
- http(Hypertext Transfer Protocol)
: 서로 다른 시스템들 사이에서 통신을 주고받게 하는 기본적인 프로토콜(규약)
  전송되는 정보가 암호화되지 않아 유출이 잦음

- https(Hypertext Transfer Protocol Secure)
: HTTP + SSL(보안 소켓 계층)
: 서버와 클라이언트 간의 모든 데이터를 암호화하여 전송하는 프로토콜


26. 디자인패턴
- 객체 지향 프로그래밍 설계 시 자주 발생하는 문제들을 피하기 위해 사용되는 패턴
